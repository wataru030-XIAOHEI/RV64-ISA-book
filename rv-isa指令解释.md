

### RV64各指令解释

本文是作为学习笔记来记录RV-ISA各指令的解释，会持续更新的。

主要以**RV64I**为主题部分，记录RV64I与其拓展所支持的指令的作用与解释。时间充足情况下会记录*<u>伪指令</u>*。

*如果文章内容有误，请在此github仓库中提出：* [这本书的库](https://github.com/wataru030-XIAOHEI/RV64-ISA-book.git)



---

#### RV64I

RV64的指令分为**I-TYPE** , **R-TYPE** , **U-TYPE** , **J-TYPE** , **S-TYPE** , **B-TYPE**这几种。记录的格式为**<inst_name>-Xtype**. 

此外，对于每一条指令的格式，以：

~~~Verilog
"------- ----- ----- --- ----- -INSTOP-" 
"??????? ????? ????? ??? ????? 00101 11"
"imm/op- rs/im  rt   fu   rs   --opcode"
~~~

这种形式来表示，最左边为第31位，最右边为第0位。根据不同指令各个部位表示的意义不同，请见下图：

| funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0] | <u>*R-TYPE*</u> |
| :-----------: | ---------- | ---------- | ------------- | -------- | ----------- | --------------- |

| imm[31:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0] | <u>*I_TYPE*</u> |
| :--------: | ---------- | ------------- | -------- | ----------- | --------------- |

| IMM[11:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | IMM[4:0] | opcode[6:0] | <u>*S-TYPE*</u> |
| :-------: | :--------: | ---------- | ------------- | -------- | ----------- | --------------- |

| IMM[12] | IMM[10:5] | rs2[24:20] | rs1[19:15] | funct3 | IMM[4:1] | IMM[11] | op   | <u>B-TYPE</u> |
| ------- | --------- | ---------- | ---------- | ------ | -------- | ------- | ---- | ------------- |

| imm[31:12] | rd[11:7] | opcode | <u>U-TYPE</u> |
| :--------: | :------: | :----: | :-----------: |

| IMM[20] | IMM[10:1] | IMM[11] | IMM[19:12] | rd[11:7] | opcode | <u>J-TYPE</u> |
| ------- | --------- | ------- | ---------- | -------- | ------ | ------------- |



---

### LOAD AND STORE

关于load（加载）与store（存储）指令的部分。

Load：指从存储器读取数据到寄存器中，提供后续运算需要。

Store：指把寄存器中的数据存储在存储器中。

##### LOAD

##### lbu-I

`"??????? ????? ????? 100 ????? 00000 11"`

lbu rd offset(rs)

立即数作有符号拓展，为地址偏移量。把存储器中8位数据（1bytes）写入寄存器rd中，再作零拓展。

##### lh-I

`"??????? ????? ????? 001 ????? 00000 11"`

lh rd offset(rs)

立即数作有符号拓展，为地址偏移量。把存储器中16位数据（2bytes）写入寄存器rd中，再做有符号拓展。

##### lhu-I

`"??????? ????? ????? 101 ????? 00000 11"`

lhu rd offset(rs)

立即数作有符号拓展作为偏移量，把存储器中的2bytes数据写入寄存器rd中，作零拓展。

##### lw-I

`"??????? ????? ????? 010 ????? 00000 11"`

lw rd offset(rs)

立即数作有符号拓展作为偏移量，把存储器中该地址开始的32位数据写入寄存器然后作有符号拓展。

##### ld-I

`"??????? ????? ????? 011 ????? 00000 11"`

ld rd offset(rs)

立即数作有符号拓展，为地址偏移量。把存储器中64位数值写入到寄存器rd中。

#### STORE

##### sb-S

`"??????? ????? ????? 000 ????? 01000 11"`

sb rs2 rs1 ,simm12

立即数作符号拓展，将寄存器rt的数据取低1byte作零拓展写入存储器。

##### sh-S

`"??????? ????? ????? 001 ????? 01000 11"`

sh rs2 rs1 ,simm12

立即数作符号拓展，将寄存器rt的数据取低2byte写入存储器。

##### sw-S

`"??????? ????? ????? 010 ????? 01000 11"`

sw rs2 rs1 ,simm12

立即数作符号拓展，将寄存器rt的数据取低32bit写入存储器。

##### sd-S

`"??????? ????? ????? 011 ????? 01000 11"`

sd rs2 rs1 ,simm12

立即数为符号拓展12位，存储地址为（rs1+simm12），把rs2的64位数据写入存储器。



---

### AUIPC AND LUI

##### auipc-U

从20位U立即数中构建一个32位偏移量，低12位补0，然后将这个偏移量加到pc上。最终送入rd。

##### lui-U

`"??????? ????? ????? ??? ????? 01101 11"`

lui rd imm

高位加载指令，将20位立即数进行左移12位，低位补0，存入rd。



---

### AND,SUB,MUL,DIV，REMW

算术指令，加减乘除与取余。

##### addi-I

`"??????? ????? ????? 000 ????? 00100 11"`

addi rd rs1,simm12

12bits立即数符号拓展位32位，与rs1寄存器做加法运算，结果存回rd。

*addi rd rs1,0可以被当做mov指令*

##### add-R

`"0000000 ????? ????? 000 ????? 01100 11"`

add rd rs1 rs2

rs1加上rs2，结果存入rd

##### addw-R

`"0000000 ????? ????? 000 ????? 01110 11"`

addw rd rs1 rs2 

取rs1加上rs2的结果低32位进行有符号拓展，有符号拓展后的结果存入rd。

##### addiw-I

`"??????? ????? ????? 000 ????? 00110 11"`

addiw rd rs imm

将立即数进行符号拓展，之后与rs的值相加，之后取低32位进行有符号拓展，有符号拓展之后的结果写入rd。

##### sub-R

`"0100000 ????? ????? 000 ????? 01100 11"`

sub rd rs1 rs2

rs1-rs2的结果写入rd。

##### subw-R

`"0100000 ????? ????? 000 ????? 01110 11"`

subw rd rs1 rs2 

取rs1-rs2的结果的低21位进行有符号拓展，拓展之后写入rd。

##### mul-R

`"0000001 ????? ????? 000 ????? 01100 11"`

mul rd rs1 rs2

将rs1*rs2的结果写入rd中。

##### mulw-R

`"0000001 ????? ????? 000 ????? 01110 11"`

mulw rd rs1 rs2

取rs1*rs2的结果低32位进行有符号拓展，将有符号拓展的结果写入rd中。

##### divw-R

`"0000001 ????? ????? 100 ????? 01110 11"`

divw rd rs1 rs2

取rs1[31:0]/rs2[31:0]的结果进行有符号拓展，将有符号拓展之后的结果写入rd中。

##### remw-R

`"0000001 ????? ????? 110 ????? 01110 11"`

取rs1[31:0]%rs2[31:0]的结果进行有符号拓展，将有符号拓展之后的结果写入rd中。



---

### SHIFT

##### srai-I

`"010000? ????? ????? 101 ????? 00100 11"`

srai rd rs1,sa 

将rs1的值进行sa位的**算术右移**。将结果写入rd。

##### sraw-R

`"0100000 ????? ????? 101 ????? 01110 11"`

sraw rd rs1,rs2

将rs1的值进行rs2[4:0]位的**算术右移**。之后进行符号拓展。将符号拓展的结果写入rd。

##### srli-I

`"000000? ????? ????? 101 ????? 00100 11"`

srli rd rs1 sa

将rs1的值进行sa位的逻辑右移，把结果写入rd。

##### srlw-R

`"0000000 ????? ????? 101 ????? 01110 11"`

srlw rd rs1 rs2

将rs1的值进行rs2[4:0]位的逻辑右移，取结果低32位进行有符号拓展。把拓展之后的结果写入rd。

##### srlwi-I

`"000000? ????? ????? 101 ????? 00110 11"`

srlwi rd rs1 sa

将rs1的值进行sa位的逻辑右移，之后进行有符号拓展。把结果写入rd。

##### sllw-R

`"0000000 ????? ????? 001 ????? 01110 11"`

sllw rd rs1 rs2

将rs1的值进行rs2[4:0]逻辑左移，之后将结果进行有符号拓展，将拓展之后的结果写入rd中。

##### slli-I

`"000000? ????? ????? 001 ????? 00100 11"`

slli rd rs1 sa

将rs1的值进行sa逻辑左移,将结果写入rd中。

##### slliw-I

`"000000? ????? ????? 001 ????? 00110 11"`

slliw rd rs1 sa

将rs1的值进行sa逻辑左移,取结果低32位进行有符号拓展，将拓展之后的结果写入rd中。



---

### AND,OR,XOR

与，或，异或

##### and-R

`"0000000 ????? ????? 000 ????? 01100 11`"

and rd rs1 rs2

将rd = rs1 &rs2的结果写入rd。位与。

##### andi-I

`"??????? ????? ????? 111 ????? 00100 11"`

andw rd rs1 imm

将rd = rs1 &(signed extend)imm的结果写入rd。位与。

##### xori-I

`"??????? ????? ????? 100 ????? 00100 11"`

xori rd rs1 rs2

将rd = rs1 ^rs2的结果写入rd。位异或。

##### or-R

`"0000000 ????? ????? 110 ????? 01100 11"`

or rd rs1 rs2

将rd = rs1| rs2的结果写入rd。位或。



---

### SLT ,SLTU,SLTUI

小于置为指令。

##### slt-R

`"0000000 ????? ????? 010 ????? 01100 11"`

slt rd rs1 rs2

rs1与rs2进行有符号对比，若rs1<rs2，将rd置为1，否则置为0.

##### sltu-R

`"0000000 ????? ????? 011 ????? 01100 11"`

sltu rd rs1 rs2

rs1与rs2进行无符号对比，若rs1<rs2，将rd置为1，否则置为0.

##### sltui-I

`"??????? ????? ????? 011 ????? 00100 11"`

sltui rd rs imm

将立即数进行有符号拓展，与rs1进行无符号比较，若rs1<imm，则把rd置1，否则置为0。



---

### Jump and Branch

##### jal-J

`"??????? ????? ????? ??? ????? 11011 11"`

jal rd,simm21

立即数为21位立即数进行符号拓展至32位**然后与当前pc相加作为跳转pc地址**。（最低位恒为0，指令中只有【20：1】的立即数）同时把下一条指令的pc（即pc+4）写入rd中。

##### jalr-I

`"??????? ????? ????? 000 ????? 11001 11"`

jalr rd,rs1,simm12

把12位立即数符号拓展至32位，然后与rs1的值相加作为pc跳转地址，同时把下一条指令的pc存入rd。

##### beq-B

`"??????? ????? ????? 000 ????? 11000 11"`

beq rs1 rs2,offset

若rs1的值与rs2的值一致，下一条指令的pc为当前pc加上offset的值。offset为符号拓展的imm。

##### bne-B

`"??????? ????? ????? 001 ????? 11000 11"`

bne rs1 rs2,offset

若rs1的值与rs2的值不一致，下一条指令的pc为当前pc加上offset的值。offset为符号拓展的imm。

##### blt-B

`"??????? ????? ????? 100 ????? 11000 11"`

blt rs1 rs2,offset

rs1与rs2进行有符号比较，若rs1<rs2，则下一条pc为当前pc加上offset。offset为符号拓展的imm。

##### bltu-B

`"??????? ????? ????? 110 ????? 11000 11"`

bltu rs1 rs2,offset

rs1与rs2进行无符号比较，若rs1<rs2，则下一条pc为当前pc加上offset。offset为符号拓展的imm。

##### bge-B

`"??????? ????? ????? 100 ????? 11000 11"`

bge rs1 rs2,offset

rs1与rs2进行有符号比较，若rs1>=rs2，则下一条pc为当前pc加上offset。offset为符号拓展的imm。



---

### About System

##### *ebreak*

Debugger用来切换加入debugger环境的。

##### *ecall*

用来调用system call